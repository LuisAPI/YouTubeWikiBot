import os
from dotenv import load_dotenv
import mwclient
import pycountry
import re  # Importing the regular expressions module

load_dotenv()
WIKI_URL = os.getenv('WIKI_URL')

def get_full_country_name(country_code):
    """Retrieve the full country name from the country code."""
    try:
        return pycountry.countries.get(alpha_2=country_code).name
    except LookupError:
        return ''

def fetch_boilerplate(page_title, wiki_url):
    """Fetch the boilerplate content from the MediaWiki page using mwclient."""
    site = mwclient.Site(wiki_url) 

    # Fetch the page
    page = site.pages[page_title]
    
    if page.exists:
        content = page.text
        # Remove content within <noinclude> tags
        content_without_noinclude = re.sub(r'<noinclude>.*?</noinclude>', '', content, flags=re.DOTALL)
        return content_without_noinclude.strip()  # Return cleaned content
    else:
        return "Error: Boilerplate page not found or inaccessible."

def generate_auto_paragraph(channel_info, join_date, statistics):
    """Generates the auto-generated paragraph for a new page."""
    paragraph = f"'''{channel_info['title']}''' is a YouTube channel"
    paragraph += f" created on {join_date}"

    # Add the subscriber count clause if available
    subscriber_count = statistics.get('subscriberCount')
    if subscriber_count:
        paragraph += f", with over {subscriber_count} subscribers"

    # Add the view count clause if available
    view_count = statistics.get('viewCount')
    if view_count:
        paragraph += f", and has accumulated {view_count} views"

    paragraph += "."
    return paragraph

def generate_wiki_content(channel_info, username, join_date, statistics):
    """Generates the content for the MediaWiki page."""
    boilerplate = fetch_boilerplate("YouTube Wiki:Channel page boilerplate", WIKI_URL)
    
    auto_paragraph = generate_auto_paragraph(channel_info, join_date, statistics)
    
    new_top_marker = """<!--
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
*           Please leave the top part alone          *
*        The info sidebar is updated regularly       *
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■-->"""
    new_bottom_marker = """<!--
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
*         Please leave the bottom part alone         *
*        The channel box is updated regularly        *
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■-->"""
    old_bottom_marker = """<!--
*         Please leave the bottom part alone         *
*        The channel box is updated regularly        *
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■-->"""
    infobox_content = f"""{{Infobox channel
|channel_name    = {channel_info['title']}
|subscribers     = {statistics.get('subscriberCount', '')}
|views           = {statistics.get('viewCount', '')}
|years_active    = {channel_info.get('years_active', '')}
|as_of           = {{subst:#time:j F Y}}
"""
    
    if new_top_marker in boilerplate and new_bottom_marker in boilerplate:
        # Extract content between new markers
        parts = boilerplate.split(new_bottom_marker)
        top_part = parts[0].split(new_top_marker)[0] + new_top_marker
        
        # Combine the top part, autogenerated paragraph, and bottom part
        wiki_content = f"{top_part}\n\n{auto_paragraph}\n\n{parts[1]}"
    
    elif old_bottom_marker in boilerplate:
        # Handle case with only the old bottom marker
        parts = boilerplate.split(old_bottom_marker)
        top_part = parts[0]  # Everything above the old marker
        
        # Combine the top part and autogenerated paragraph
        wiki_content = f"{top_part}\n\n{auto_paragraph}\n\n{old_bottom_marker}"

    else:
        # Fallback if no markers are found
        wiki_content = boilerplate

    return wiki_content


def combine_content(existing_content, marker_comment, wiki_content, auto_paragraph=None):
    """Combines content for the wiki page update."""
    if auto_paragraph:
        # New page, include auto-paragraph
        return auto_paragraph + "\n\n" + wiki_content
    else:
        # Update existing page without auto-paragraph
        if marker_comment in existing_content:
            # Replace content after the marker comment
            return existing_content.split(marker_comment)[0] + wiki_content
        else:
            # Append new content
            return existing_content + "\n" + wiki_content
